<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <style>
      .tab-button {
        padding: 6px 10px;
        border-top-left-radius: 3px;
        border-top-right-radius: 3px;
        border: 1px solid #ccc;
        cursor: pointer;
        background: #f0f0f0;
        margin-bottom: -1px;
        margin-right: -1px;
      }
      .tab-button:hover {
        background: #e0e0e0;
      }
      .tab-button.active {
        background: #e0e0e0;
      }
      .tab {
        border: 1px solid #ccc;
        padding: 10px;
      }
    </style>
  </head>
<body>
  <nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">Navbar</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
          <li class="nav-item">
            <a class="nav-link active" aria-current="page" href="#">Home</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">Link</a>
          </li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
              Dropdown
            </a>
            <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
              <li><a class="dropdown-item" href="#">Action</a></li>
              <li><a class="dropdown-item" href="#">Another action</a></li>
              <li><hr class="dropdown-divider"></li>
              <li><a class="dropdown-item" href="#">Something else here</a></li>
            </ul>
          </li>
          <li class="nav-item">
            <a class="nav-link disabled" href="#" tabindex="-1" aria-disabled="true">Disabled</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

    <div id="app" class="container">

      <div>
        <h2> i componenti su vue  </h2>
        <div> componente esempio  <br>
        <button-counter></button-counter>
        <br>
        <div> Poiche i componenti sono instanze vue riutilizzabili  , accetttano le stesse opzioni 
        <span class="text-primary"> di new Vue , come data ,computed , watch ,  methods  e gli hook del ciclo
        di vita  </span> le uniche eccezzioni sono alcune opzioni specifiche della radice come
        <span class="text-primary"> el </span> </div>
        </div>
      </div>
      <hr><br>

      <div>
        <h2> Riutilizzo dei componenti su vue  </h2>
        <div> i componeneti posso essere riutilizzati tutte le volte che vuoi   <br>
        <button-counter></button-counter> <br>
        <button-counter></button-counter> <br>
        <button-counter></button-counter> <br>
        <br>
        <div> Si noti che quando si fa click <span class="text-primary"> sui pulsanti ognuno mantiene il 
        propio count . </span> Questo perche ogni volta che <span class="text-primary"> usi un componente 
        ne viene creata una nuova instanza </span> </div>
        </div>
      </div>
      <hr><br>

      <div>
        <h2> <span class="text-primary"> Data </span> deve essere una funzione </h2>
        <div> quando abbiamo <span> definito il </button-counter> componente </span> , potresti aver 
        notato che data non e stato fornito direttamente un oggetto , come questo :  <br>
          <div>
            data : { <br>
              count : 0 <br>
            } <br>
          </div>
          <div> invece l'opzione <span class="text-primary"> data di un componente deve 
          essere una funzione </span> , in modo che ogni instanza possa mantere una copia
          indipendente dell'oggetto dati restituito  </div>
          <div> 
            data : function(){ <br>
              return { <br>
                count : 0 <br>
              }
            } <br>
          </div>
          <div> Se vue non avesse questa regola , fare click su un pulsante influirebbe sui dati di tutte 
          le altre instanze . <span class="text-primary"> adesso vue ha un controllo su questo ,
          qundi se data non e una funzione vue va in errore .</span>
          </div>
        </div>
      </div>
      <hr><br>

      <div>
        <h2> Organizzazione dei componenti  </h2>
        <div>E comune che un app sia organizzata in un albero di componenti nidificati : 
          Ad esempio potresti avere componenti per un'intestazione , una barra laterale e 
          un'area di contenuto ciascuno contenete in genere altri componenti per collegamenti 
          di navigazione , post di blog e cosi via . 
          Per utilizzare questi componenti e necessario registrarli in modo che Vue li conosca . 
        </div> 
          <div>  i componenti possono essere registrati a <span class="text-primary">  
          livello globale o locale . </span> <br>
          Per registrare un componente a <span class="text-primary">  livello globale usiamo il Vue.component </span> <br>
          Per registrare un componeente a <span class="text-primary"> livello locale usiamo   </span> </div>
     
        <hr>
        <h2> Vue component </h2>
        <div>
          Vue.component('my_component_name',{ <br>
            // ..... option ...... <br>
          }) <br>
        </div>
        <hr>
        <div> i componenti registrati a livello globale possono essere usati da 
          <span class="text-info"> qualunque instanza Vue radice ( new Vue ) </span> 
          creata in seguito e anche all'interno di tutti i sotto componenti  dell'albero
          dei componeti di quell'instanza Vue  
        </div>
      </div>
      <hr><br>

      <div>
        <h2> Passaggio di dati a componenti figli con prop   </h2>
        <div> Gli oggetti di scena sono degli attributi dinamici che puoi registrare su un componente.
          Quando un valore viene passatto ad un attributo prop , diventa una propita su quell'instanza del componente.
          Per passare un titolo sul nostro componentedel posto sul blog , possiamo includerlo nell'elenco 
          degli oggetti di scena accettati da quel componente , <span class="text-primary"> utilizzando l'opzione props : </span>  <br>
          Vue.component('blog-post', {  <br>
            props: ['title'], <br>
            template: '<h3>{{ title }}</h3>' <br>
          }) <br>
          e possibile passare dati personalizzati alla prop di ogni componete con il seguente codice : <br> 
          < blog-post title="My journey with Vue" >< /blog-post> <br> 

        </div>
        <blog-post title="My journey with Vue" ></blog-post>
        <blog-post title="Blogging with Vue" ></blog-post>
        <blog-post title="Why Vue is so fun" ></blog-post>
        <hr>
        <div> <h4 class="text-danger"> in un app tipica avra dei post dentro data , come sotto (vedi posts) </h4> </div>
        <blog-post 
        v-for="post in posts" 
        v-bind:key="post.id"
        v-bind:title="post.title"
        ></blog-post>
        <div> Sopra , vedrai che possiamo usare <span class="text-primary"> il v-bind  per passare dinamicamente </span>
          gli oggetti di scena . Cio e particolarmentte utile quando non si conosce il contenuto esatto di cui si vuole
          eseguire il rendering in anticipo , ad esempio <span class="text-danger">  quando si recuperano i post da un API 
          </span> .

        </div>
      </div>
      <hr><br>

      <div>
        <h2> Un singolo elemento radice </h2>
        <div> 
          Quando crei un < blog-post>< /blog-post> componente il tuo modello alla fine conterrà piu del semplice titolo : <br>
          < h3> { { title } } < /h3> <br>
          Per lo meno ti consigliamo di includere il contenuto del post  : 
          < h3> { { title }} < /h3>
          < div v-html="content"></ div>
          Se lo provi ad inserire nel componente Vue mostrerà un errore spiegando che  
          <span class="text-primary">  ogni componente deve avere un singolo elemento radice </span> . Puoi correggere 
          questo errore avvolgendo il modello in un elemento padre , ad esempio : <br>
          < di v class="blog-post" > <br>
          < h3> {{ title }} < /h3>
          <  di v v-html="content"> < /div>
          < /div>
          <div> 
              Man mano che il componente cresce e probabile che non avremo bisogno solo del titolo e del contenuto del post , 
              ma anche della data di pubblicazione dei commenti ed altro ancora . Definire un supporto per ogni per ogni 
              informazione correlata pottrebbe diventare moltto fastidioso : 
              < blog-post  <br>
              v-for="post in posts" <br>
              v-bind:key="post.id" <br>
              v-bind:title="post.title" <br>
              v-bind:content="post.content" <br>
              v-bind:publishedAt="post.publishedAt" <br>
              v-bind:comments="post.comments" <br>
              >< /blog-post> <br>
              <hr>
              Qindi questo potrebbe essere un buon momneto per il refactoring del < blog-post>< /blog-post> componente
              per accettare <span class="text-primary"> post </span> invece  <span class="text-danger"> un singolo oggetto di scena </span> <br> 
              < blog-post > <br>
              v-for="post in posts" <br>
              v-bind:key="post.id" <br>
              v-bind:post="post" <br>
              < /blog-post > <br>
              <blog-post
                v-for="post in posts"
                v-bind:key="post.id" 
                v-bind:post="post" 
              ></blog-post>
          </div>
        </div>
      </div>
      <hr><br>

      <div>
        <h2> Ascolto degli eventi su un componente figlio  </h2>
        <div> 
          Mentre sviluppiamo il nostro <span class="text-primary">   < blog-post > alcune funzionalita potrebbero  </span>  
          richiedere la comunicazione di back-up al genitore . Ad esempio  , 
          potremmo decidere di includere una funzione di accessibilita per ingrandire il 
          testo dei post del blog , lasciando il resto della pagina alla sua dimensione predefinita . 
          Nel genitore possiamo supportare questa funzione aggiungendo
          <span class="text-primary"> postFontSize propieta ai dati .</span>  <br>
            <div v-bind:style="{ fontSize : postFontSize + 'em' } ">
              <div :style="{ fontSize: postFontSize + 'em' }">
              <blog-post
                v-for="post in posts"
                v-bind:key="post.id" 
                v-bind:post="post" 
            ></blog-post>
            </div>
            <hr><br>
            <h3 class="text-danger">  enlarge-text work only in this section ---------------  </h3>
            <div>Quando clicchiamo sul bottono dobbiamo comunicare al genitore che dovrebbe 
              ingrandire il testo di tutti i post . Fortunatamente le instanze vue forniscono
              un set di eventi peersonalizzato per risolvere questo problema  . Il genitore puo 
              scegliere di ascoltare qualsiasi eveneto sull'instnza del componente figlio con 
              <span class="text-primary"> v-on </span> , propio come faremo per un evento DOM nativo
              < blog-post
              ... 
              v-on:enlarge-text="postFontSize +=0.1"
              > < /blog-post>

              <blog-post
                v-for="post in posts"
                v-bind:key="post.id" 
                v-bind:post="post" 
                v-on:enlarge-text="postFontSize += 0.1"
              ></blog-post>
            Grazie v-on:enlarge-text="postFontSize += 0.1 ", all'ascoltatore il genitore ricevera 
            l'evento e il postFontSize valore di aggiornamento 
            </div>
        </div>
      </div>

      <div>
        <h2> Emettere un valore con un evento </h2>
        <div> 
         A volte e utile emettere un valore specifico con un evento . ad esempio , potremmo 
         volere che il < blog-post> componenete sia incaricato di quanto ingrandire il testo . 
         In questi casi  , possiamo utilizzare $emit , il 2° parametro di per fornire questo valore .
            <hr><br>
            <div>Quindi quando ascoltiamo l'evento nel genitore , possiamo accedere al valore 
              dell'evento emesso con $event :
              <blog-post
                v-for="post in posts"
                v-bind:key="post.id" 
                v-bind:post="post" 
                v-on:enlarge-text="postFontSize += $event "
              ></blog-post>
              <hr><br>
              <div> Oppure , <span class="text-primary">  se il gestore dell'evento e un metodo </span> : 
                <blog-post
                v-for="post in posts"
                v-bind:key="post.id" 
                v-bind:post="post" 
                v-on:enlarge-text="onEnlargeText"
              ></blog-post>
              </div>
              <br><hr>
              <div></div>
            Grazie v-on:enlarge-text="postFontSize += 0.1 ", all'ascoltatore il genitore ricevera 
            l'evento e il postFontSize valore di aggiornamento 
            </div>
        </div>
      </div>
      <hr><br>

      <div>
        <h2> Utilizzo <span class="text-primary"> v-model sui componenti </span> </h2>
        <div> 
          <span class="text-primary"> Gli eventi personalizzati </span> possono essere usati anche per creare
          input personalizzati che <span class="text-primary"> funzionano con v-model  </span> <br>

          <input v-model="searchtext"> <br>
            <span class="text-primary"> fa la stessa cosa di : </span> <br> 
          <input 
          v-bind:value="searchtext" 
          v-on:input="searchtext = $event.target.value "
          type="text"> <br>
          <hr><br>
          <span class="text-primary"> Quando viene utilizzato su un componente v-model invece fa questo </span> <br>
          <custom-input
          v-bind:value="searchtext"
          v-on:input="searchtext = $event "
          />
        </div>
        <hr><br>
        <div>
          <span class="text-primary">Affinche cio funzioni correttamente l'input del componente deve : </span> <br>
          1) assocciare <span class="text-primary"> value attributo </span> con un <span class="text-primary"> value in scena </span> <br>
          2) su <span class="text-primary"> input </span> emetti il propio <span class="text-primary"> input </span> 
          evento personalizzato con il nuovo valore <br> 
            <span class="text-primary"> Eccolo in azione : </span> <br>
            Ora v-model dovrebbe funzionare perfettamente con questo componente : <br> <br> 
            <custom-input v-model="searchtext"></custom-input>
        </div>
      </div>

      <div>
        <h2> Distribuzione dei contenuti con slot </h2>
        <div> 
          Propio come tutti gli elementi HTML, è spesso utile poter passare il contenuto a un 
          componente  , come questo :  

          <alert-box>
            è successo qualcosa di brutto 
          </alert-box>
           <br>
          Fortunatamente , questo compito e realizzato semplicemente con un elemento Vue personalizzato < slot> 
          Come vedrai sopra , <span class="text-primary"> aggiungendo semplicemente lo slot dove vogliamo che vada
          </span> - e il gioco e fatto . e abbiamo fatto
          <span class="text-primary"> lo slot sara il punto in cui verrano inseriti i dati che andiamo a passare </span>
        </div>
      </div>
      <hr><br>

      <div>
        <h2> Avvertenze sull' <span class="text-primary"> Analisi del modello DOM </span> </h2>
        <div> 
          <span class="text-primary"> Alcuni componenti HTML come < ul> ,  < li> , < table> , e < select>   ,  
          hanno restrizioni su quali elementi possono apparire al loro interno </span> e alcuni elementi come 
          < li> , < tr> e < option> possono apparire solo all'interno di certi elementi . <br>

          Cio portera a problemi quando si utilizzano componenti con elementi che hanno tali restrizioni . <br>
          <span class="text-primary"> Per esempio : </span><br>
          < table> <br>
            < blog-post-row>< /blog-post-row> <br>
          < /table> <br>
          <span class="text-primary"> Il componente blog-post-row verra segnalato come contenuto non valido  </span> , 
          causando errori nell'eventuale output di rendering . <br>
          <span class="text-primary"> Fortunatamente l'is attributo speciale offre una soluzione alternativa  :  </span> <br>
          < table> <br>
            < tr is="blog-post-row">< /tr> <br>
          < /table> <br>

          Va notato : <span class="text-primary"> che questa limitazione non si applica se si utilizzano modelli di 
          stringhe da una delle seguenti origini </span> <br>
          <ul>
            <li> Modelli di stringhe ( ad esempio :  <span class="text-danger"> template : " ...... " </span> )</li> 
            <li> Componenti a file singolo ( ad esempio : <span class="text-danger"> .vue  </span> )</li> 
            <li> <span class="text-danger"> < script type="text/x-template"> </span> </li> 
          </ul>
         
        </div>
      </div>
      <hr><br>

      <div>
        <h2> Componenti Dinamici </h2>
        <div> 
          A volte , e utile passarre da un componente all'altro  , come in un 
          interaccia a schede :

          < component> Questo sopra ee reso possibile dall'elemento di 
          <span class="text-primary"> vue con l'is attributo speciale  </span> 

          <div id="dynamic-component-demo" class="demo">
            <button
              v-for="tab in tabs"
              v-bind:key="tab"
              v-bind:class="['tab-button', { active: currentTab === tab }]"
              v-on:click="currentTab = tab"
            >
              {{ tab }}
            </button>
      
            <component v-bind:is="currentTabComponent" class="tab"></component>
          </div>

          Nell'esempio sopra currentTabComponent puo contenere : <ul> 
            <li>il nome di un oggetto rgistrato ,o  </li>
            <li>l'oggetto opzioni di un componente </li>
          </ul>
          Tiene presente che <span class="text-primary"> questo attributo puo essere utilizzato con normali elementi html </span>,
          tuttavia verranno trattati come componenti , il che significa che <span class="text-primary">  tutti gli attributi
           saranno associati come attributi DOM </span> . <br>
           <span class="text-primary"> affinche alcune propieta value funzionino </span>  come ci si aspetterebbe
           <span class="text-primary"> sara necessario utilizzarle il .prop modificatore </span>
        </div>
      </div>

    </div>

  <div id="app_2" class="container">

    <div>
      <h2> Seconda instanza vue bind su app_2 </h2>
      <div> componente esempio  <br>
      <button-counter></button-counter>
      </div>
    </div>
    <hr><br>

  </div>

<!-- bootstrap 5 cdn js -->
<script 
  src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous">

</script>
<!-- jqeruy cdn  -->
<script
  src="https://code.jquery.com/jquery-3.6.0.js"
  integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk="
  crossorigin="anonymous">
</script>
  <!-- vue js cdn  -->
<script 
  src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js">
</script>   
<!-- script vue -->
<script>
// Definisco un nuovo componente chiamato button-counter 
Vue.component('button-counter' , {
  data : function () {
    return {
      count : 0
    } 
  },
  template :  `
    <div> 
      <button v-on:click="count++" type="button" class="btn btn-info"> 
        Mi hai cliccato {{ count }} volte 
      </button>
    </div>
  `
});
//componente blog-post
Vue.component('blog-post',{ 
  props : ['post'] ,
  template : ` 
    <div class="blog-post"> 
      <hr>
      <h3> {{ post.id }} </h3>
      <h3> {{ post.title }} </h3>
      <button v-on:click="$emit('enlarge-text' , 0.1 )">
       Enlarge text
      </button>
      <div v-html="post.content"> </div>
      <div v-html="post.publishedAt"> </div>
      <div v-html="post.comments"> </div>
    </div>
   `,
});

Vue.component('custom-input',{
  props: ['value'] ,
  template : `
    <input 
    v-bind:value="value"
    v-on:input="$emit( 'input', $event.target.value)"
    />
  `
});

Vue.component('alert-box',{
  template : `
  <div class="alert alert-danger">
    <strong> Errore! </strong>
    <slot></slot>
  </div>
  `
});

// tab component 
Vue.component("tab-home", {
  template: "<div>Home component</div>"
});
Vue.component("tab-posts", {
  template: "<div>Posts component</div>"
});
Vue.component("tab-archive", {
  template: "<div>Archive component</div>"
});

//i componenti devono essegere registrati prima che si effettua il bind con app o non saranno registrati
//bastava la linea sotto commentatta ma definiamo il modo completo vue 
//new Vue ({ el:'#app'});

var data = {
  a: 1 , 
  msg : 'benvenuto', 
  rawHtml:'<span style="color:red">this text should be red</span>', 
  dynamicId:'id_prova' ,
  //   il bottone non sara rendirizzato da vue quando disabled e false , null , undefined 
  isButtonDisabled: undefined , 
  // isButtonDisabled:'disabled',  
  seen:false, 
  url: 'ciao',
  doSomethings : 'vuoto',
  attributename : 'href' ,  // usato nel test attributi dinamici
  event : 'click' ,
  click : 0 , 
  posts : [
    { id: 1, title: 'My journey with Vue' , content:"content 1" , publishedAt:"today 1 " , comments : "comments 1"},
    { id: 2, title: 'Blogging with Vue' , content:"content 2" , publishedAt:"today 2 " , comments : "comments 2"},
    { id: 3, title: 'Why Vue is so fun' , content:"content 3" , publishedAt:"today 3 " , comments : "comments 3"},
  ],
  postFontSize: 1,
  searchtext : '',
  currentTab: "Home",
  tabs: ["Home", "Posts", "Archive"]
}

var vm = new Vue({
  el: '#app',
  data: data,
  created: function () {
  },
  computed : {
    currentTabComponent: function() {
      return "tab-" + this.currentTab.toLowerCase();
    }

  },
  methods : {
    onEnlargeText : function(enlargeAmount){
      this.postFontSize += enlargeAmount

    }

  },
  watch :{

  },
})

var data2 = {
  a: 1 , 
  msg : 'benvenuto', 
  rawHtml:'<span style="color:red">this text should be red</span>', 
  dynamicId:'id_prova' ,
  //   il bottone non sara rendirizzato da vue quando disabled e false , null , undefined 
  isButtonDisabled: undefined , 
  // isButtonDisabled:'disabled',  
  seen:false, 
  url: 'ciao',
  doSomethings : 'vuoto',
  attributename : 'href' ,  // usato nel test attributi dinamici
  event : 'click' ,
  click : 0 , 
  posts : [
    { id: 1, title: 'My journey with Vue' },
    { id: 2, title: 'Blogging with Vue' },
    { id: 3, title: 'Why Vue is so fun' },
  ],
}

var vm2 = new Vue({
  el: '#app_2',
  data: data2,
  created: function () {
  },
  computed : {

  },
  methods : {

  },
  watch :{

  },
})

</script> 

</body>
</html>
